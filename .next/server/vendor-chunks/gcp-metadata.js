"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gcp-metadata";
exports.ids = ["vendor-chunks/gcp-metadata"];
exports.modules = {

/***/ "(action-browser)/./node_modules/gcp-metadata/build/src/gcp-residency.js":
/*!**************************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/gcp-residency.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.detectGCPResidency = exports.isGoogleComputeEngine = exports.isGoogleComputeEngineMACAddress = exports.isGoogleComputeEngineLinux = exports.isGoogleCloudServerless = exports.GCE_LINUX_BIOS_PATHS = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst os_1 = __webpack_require__(/*! os */ \"os\");\n/**\n * Known paths unique to Google Compute Engine Linux instances\n */\nexports.GCE_LINUX_BIOS_PATHS = {\n    BIOS_DATE: '/sys/class/dmi/id/bios_date',\n    BIOS_VENDOR: '/sys/class/dmi/id/bios_vendor',\n};\nconst GCE_MAC_ADDRESS_REGEX = /^42:01/;\n/**\n * Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).\n *\n * Uses the:\n * - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n * - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.\n *\n * @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.\n */\nfunction isGoogleCloudServerless() {\n    /**\n     * `CLOUD_RUN_JOB` is used for Cloud Run Jobs\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     *\n     * `FUNCTION_NAME` is used in older Cloud Functions environments:\n     * - See {@link https://cloud.google.com/functions/docs/env-var Python 3.7 and Go 1.11}.\n     *\n     * `K_SERVICE` is used in Cloud Run and newer Cloud Functions environments:\n     * - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.\n     * - See {@link https://cloud.google.com/functions/docs/env-var Cloud Functions newer runtimes}.\n     */\n    const isGFEnvironment = process.env.CLOUD_RUN_JOB ||\n        process.env.FUNCTION_NAME ||\n        process.env.K_SERVICE;\n    return !!isGFEnvironment;\n}\nexports.isGoogleCloudServerless = isGoogleCloudServerless;\n/**\n * Determines if the process is running on a Linux Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.\n */\nfunction isGoogleComputeEngineLinux() {\n    if ((0, os_1.platform)() !== 'linux')\n        return false;\n    try {\n        // ensure this file exist\n        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);\n        // ensure this file exist and matches\n        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, 'utf8');\n        return /Google/.test(biosVendor);\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;\n/**\n * Determines if the process is running on a Google Compute Engine instance with a known\n * MAC address.\n *\n * @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.\n */\nfunction isGoogleComputeEngineMACAddress() {\n    const interfaces = (0, os_1.networkInterfaces)();\n    for (const item of Object.values(interfaces)) {\n        if (!item)\n            continue;\n        for (const { mac } of item) {\n            if (GCE_MAC_ADDRESS_REGEX.test(mac)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;\n/**\n * Determines if the process is running on a Google Compute Engine instance.\n *\n * @returns {boolean} `true` if the process is running on GCE, `false` otherwise.\n */\nfunction isGoogleComputeEngine() {\n    return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();\n}\nexports.isGoogleComputeEngine = isGoogleComputeEngine;\n/**\n * Determines if the process is running on Google Cloud Platform.\n *\n * @returns {boolean} `true` if the process is running on GCP, `false` otherwise.\n */\nfunction detectGCPResidency() {\n    return isGoogleCloudServerless() || isGoogleComputeEngine();\n}\nexports.detectGCPResidency = detectGCPResidency;\n//# sourceMappingURL=gcp-residency.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nY3AtbWV0YWRhdGEvYnVpbGQvc3JjL2djcC1yZXNpZGVuY3kuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsNkJBQTZCLEdBQUcsdUNBQXVDLEdBQUcsa0NBQWtDLEdBQUcsK0JBQStCLEdBQUcsNEJBQTRCO0FBQzFNLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvR0FBb0c7QUFDMUcsTUFBTSw0RkFBNEY7QUFDbEc7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9HQUFvRztBQUNsSDtBQUNBO0FBQ0EsY0FBYyw2RUFBNkU7QUFDM0Y7QUFDQTtBQUNBLGNBQWMsb0dBQW9HO0FBQ2xILGNBQWMscUZBQXFGO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9ydGN1dF9hcHAvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9nY3AtcmVzaWRlbmN5LmpzPzdiZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRldGVjdEdDUFJlc2lkZW5jeSA9IGV4cG9ydHMuaXNHb29nbGVDb21wdXRlRW5naW5lID0gZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzID0gZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCA9IGV4cG9ydHMuaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MgPSBleHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTID0gdm9pZCAwO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XG4vKipcbiAqIEtub3duIHBhdGhzIHVuaXF1ZSB0byBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgTGludXggaW5zdGFuY2VzXG4gKi9cbmV4cG9ydHMuR0NFX0xJTlVYX0JJT1NfUEFUSFMgPSB7XG4gICAgQklPU19EQVRFOiAnL3N5cy9jbGFzcy9kbWkvaWQvYmlvc19kYXRlJyxcbiAgICBCSU9TX1ZFTkRPUjogJy9zeXMvY2xhc3MvZG1pL2lkL2Jpb3NfdmVuZG9yJyxcbn07XG5jb25zdCBHQ0VfTUFDX0FERFJFU1NfUkVHRVggPSAvXjQyOjAxLztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgR29vZ2xlIENsb3VkIFNlcnZlcmxlc3MgZW52aXJvbm1lbnQgKENsb3VkIFJ1biBvciBDbG91ZCBGdW5jdGlvbnMgaW5zdGFuY2UpLlxuICpcbiAqIFVzZXMgdGhlOlxuICogLSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAqIC0ge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9mdW5jdGlvbnMvZG9jcy9lbnYtdmFyIENsb3VkIEZ1bmN0aW9ucyBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBHQ1Agc2VydmVybGVzcywgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ2xvdWRTZXJ2ZXJsZXNzKCkge1xuICAgIC8qKlxuICAgICAqIGBDTE9VRF9SVU5fSk9CYCBpcyB1c2VkIGZvciBDbG91ZCBSdW4gSm9ic1xuICAgICAqIC0gU2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vcnVuL2RvY3MvY29udGFpbmVyLWNvbnRyYWN0I2Vudi12YXJzIENsb3VkIFJ1biBlbnZpcm9ubWVudCB2YXJpYWJsZXN9LlxuICAgICAqXG4gICAgICogYEZVTkNUSU9OX05BTUVgIGlzIHVzZWQgaW4gb2xkZXIgQ2xvdWQgRnVuY3Rpb25zIGVudmlyb25tZW50czpcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIgUHl0aG9uIDMuNyBhbmQgR28gMS4xMX0uXG4gICAgICpcbiAgICAgKiBgS19TRVJWSUNFYCBpcyB1c2VkIGluIENsb3VkIFJ1biBhbmQgbmV3ZXIgQ2xvdWQgRnVuY3Rpb25zIGVudmlyb25tZW50czpcbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3J1bi9kb2NzL2NvbnRhaW5lci1jb250cmFjdCNlbnYtdmFycyBDbG91ZCBSdW4gZW52aXJvbm1lbnQgdmFyaWFibGVzfS5cbiAgICAgKiAtIFNlZSB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2Z1bmN0aW9ucy9kb2NzL2Vudi12YXIgQ2xvdWQgRnVuY3Rpb25zIG5ld2VyIHJ1bnRpbWVzfS5cbiAgICAgKi9cbiAgICBjb25zdCBpc0dGRW52aXJvbm1lbnQgPSBwcm9jZXNzLmVudi5DTE9VRF9SVU5fSk9CIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkZVTkNUSU9OX05BTUUgfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuS19TRVJWSUNFO1xuICAgIHJldHVybiAhIWlzR0ZFbnZpcm9ubWVudDtcbn1cbmV4cG9ydHMuaXNHb29nbGVDbG91ZFNlcnZlcmxlc3MgPSBpc0dvb2dsZUNsb3VkU2VydmVybGVzcztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIGEgTGludXggR29vZ2xlIENvbXB1dGUgRW5naW5lIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvbiBMaW51eCBHQ0UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCgpIHtcbiAgICBpZiAoKDAsIG9zXzEucGxhdGZvcm0pKCkgIT09ICdsaW51eCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBlbnN1cmUgdGhpcyBmaWxlIGV4aXN0XG4gICAgICAgICgwLCBmc18xLnN0YXRTeW5jKShleHBvcnRzLkdDRV9MSU5VWF9CSU9TX1BBVEhTLkJJT1NfREFURSk7XG4gICAgICAgIC8vIGVuc3VyZSB0aGlzIGZpbGUgZXhpc3QgYW5kIG1hdGNoZXNcbiAgICAgICAgY29uc3QgYmlvc1ZlbmRvciA9ICgwLCBmc18xLnJlYWRGaWxlU3luYykoZXhwb3J0cy5HQ0VfTElOVVhfQklPU19QQVRIUy5CSU9TX1ZFTkRPUiwgJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIC9Hb29nbGUvLnRlc3QoYmlvc1ZlbmRvcik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5pc0dvb2dsZUNvbXB1dGVFbmdpbmVMaW51eCA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZUxpbnV4O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gYSBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgaW5zdGFuY2Ugd2l0aCBhIGtub3duXG4gKiBNQUMgYWRkcmVzcy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NFIChhcyBkZXRlcm1pbmVkIGJ5IE1BQyBhZGRyZXNzKSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MoKSB7XG4gICAgY29uc3QgaW50ZXJmYWNlcyA9ICgwLCBvc18xLm5ldHdvcmtJbnRlcmZhY2VzKSgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBPYmplY3QudmFsdWVzKGludGVyZmFjZXMpKSB7XG4gICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbWFjIH0gb2YgaXRlbSkge1xuICAgICAgICAgICAgaWYgKEdDRV9NQUNfQUREUkVTU19SRUdFWC50ZXN0KG1hYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZU1BQ0FkZHJlc3MgPSBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gYSBHb29nbGUgQ29tcHV0ZSBFbmdpbmUgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdDRSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzR29vZ2xlQ29tcHV0ZUVuZ2luZSgpIHtcbiAgICByZXR1cm4gaXNHb29nbGVDb21wdXRlRW5naW5lTGludXgoKSB8fCBpc0dvb2dsZUNvbXB1dGVFbmdpbmVNQUNBZGRyZXNzKCk7XG59XG5leHBvcnRzLmlzR29vZ2xlQ29tcHV0ZUVuZ2luZSA9IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvY2VzcyBpcyBydW5uaW5nIG9uIEdvb2dsZSBDbG91ZCBQbGF0Zm9ybS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9jZXNzIGlzIHJ1bm5pbmcgb24gR0NQLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0R0NQUmVzaWRlbmN5KCkge1xuICAgIHJldHVybiBpc0dvb2dsZUNsb3VkU2VydmVybGVzcygpIHx8IGlzR29vZ2xlQ29tcHV0ZUVuZ2luZSgpO1xufVxuZXhwb3J0cy5kZXRlY3RHQ1BSZXNpZGVuY3kgPSBkZXRlY3RHQ1BSZXNpZGVuY3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nY3AtcmVzaWRlbmN5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/gcp-metadata/build/src/gcp-residency.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/gcp-metadata/build/src/index.js":
/*!******************************************************!*\
  !*** ./node_modules/gcp-metadata/build/src/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.requestTimeout = exports.setGCPResidency = exports.getGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.bulk = exports.universe = exports.project = exports.instance = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(action-browser)/./node_modules/gaxios/build/src/index.js\");\nconst jsonBigint = __webpack_require__(/*! json-bigint */ \"(action-browser)/./node_modules/json-bigint/index.js\");\nconst gcp_residency_1 = __webpack_require__(/*! ./gcp-residency */ \"(action-browser)/./node_modules/gcp-metadata/build/src/gcp-residency.js\");\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });\n/**\n * Metadata server detection override options.\n *\n * Available via `process.env.METADATA_SERVER_DETECTION`.\n */\nexports.METADATA_SERVER_DETECTION = Object.freeze({\n    'assume-present': \"don't try to ping the metadata server, but assume it's present\",\n    none: \"don't try to ping the metadata server, but don't try to use it either\",\n    'bios-only': \"treat the result of a BIOS probe as canonical (don't fall back to pinging)\",\n    'ping-only': 'skip the BIOS probe, and go straight to pinging',\n});\n/**\n * Returns the base URL while taking into account the GCE_METADATA_HOST\n * environment variable if it exists.\n *\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\n */\nfunction getBaseUrl(baseUrl) {\n    if (!baseUrl) {\n        baseUrl =\n            process.env.GCE_METADATA_IP ||\n                process.env.GCE_METADATA_HOST ||\n                exports.HOST_ADDRESS;\n    }\n    // If no scheme is provided default to HTTP:\n    if (!/^https?:\\/\\//.test(baseUrl)) {\n        baseUrl = `http://${baseUrl}`;\n    }\n    return new URL(exports.BASE_PATH, baseUrl).href;\n}\n// Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\nfunction validate(options) {\n    Object.keys(options).forEach(key => {\n        switch (key) {\n            case 'params':\n            case 'property':\n            case 'headers':\n                break;\n            case 'qs':\n                throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n            default:\n                throw new Error(`'${key}' is not a valid configuration option.`);\n        }\n    });\n}\nasync function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {\n    let metadataKey = '';\n    let params = {};\n    let headers = {};\n    if (typeof type === 'object') {\n        const metadataAccessor = type;\n        metadataKey = metadataAccessor.metadataKey;\n        params = metadataAccessor.params || params;\n        headers = metadataAccessor.headers || headers;\n        noResponseRetries = metadataAccessor.noResponseRetries || noResponseRetries;\n        fastFail = metadataAccessor.fastFail || fastFail;\n    }\n    else {\n        metadataKey = type;\n    }\n    if (typeof options === 'string') {\n        metadataKey += `/${options}`;\n    }\n    else {\n        validate(options);\n        if (options.property) {\n            metadataKey += `/${options.property}`;\n        }\n        headers = options.headers || headers;\n        params = options.params || params;\n    }\n    try {\n        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n        const res = await requestMethod({\n            url: `${getBaseUrl()}/${metadataKey}`,\n            headers: { ...exports.HEADERS, ...headers },\n            retryConfig: { noResponseRetries },\n            params,\n            responseType: 'text',\n            timeout: requestTimeout(),\n        });\n        // NOTE: node.js converts all incoming headers to lower case.\n        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n            throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n        }\n        else if (!res.data) {\n            throw new Error('Invalid response from the metadata service');\n        }\n        if (typeof res.data === 'string') {\n            try {\n                return jsonBigint.parse(res.data);\n            }\n            catch (_a) {\n                /* ignore */\n            }\n        }\n        return res.data;\n    }\n    catch (e) {\n        const err = e;\n        if (err.response && err.response.status !== 200) {\n            err.message = `Unsuccessful response status code. ${err.message}`;\n        }\n        throw e;\n    }\n}\nasync function fastFailMetadataRequest(options) {\n    const secondaryOptions = {\n        ...options,\n        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS)),\n    };\n    // We race a connection between DNS/IP to metadata server. There are a couple\n    // reasons for this:\n    //\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\n    //    detect the runtime environment signficantly faster.\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\n    //    on a user's local machine.\n    //\n    // Additional logic has been added to make sure that we don't create an\n    // unhandled rejection in scenarios where a failure happens sometime\n    // after a success.\n    //\n    // Note, however, if a failure happens prior to a success, a rejection should\n    // occur, this is for folks running locally.\n    //\n    let responded = false;\n    const r1 = (0, gaxios_1.request)(options)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r2;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    const r2 = (0, gaxios_1.request)(secondaryOptions)\n        .then(res => {\n        responded = true;\n        return res;\n    })\n        .catch(err => {\n        if (responded) {\n            return r1;\n        }\n        else {\n            responded = true;\n            throw err;\n        }\n    });\n    return Promise.race([r1, r2]);\n}\n/**\n * Obtain metadata for the current GCE instance.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const serviceAccount: {} = await instance('service-accounts/');\n * const serviceAccountEmail: string = await instance('service-accounts/default/email');\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction instance(options) {\n    return metadataAccessor('instance', options);\n}\nexports.instance = instance;\n/**\n * Obtain metadata for the current GCP project.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const projectId: string = await project('project-id');\n * const numericProjectId: number = await project('numeric-project-id');\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction project(options) {\n    return metadataAccessor('project', options);\n}\nexports.project = project;\n/**\n * Obtain metadata for the current universe.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const universeDomain: string = await universe('universe_domain');\n * ```\n */\nfunction universe(options) {\n    return metadataAccessor('universe', options);\n}\nexports.universe = universe;\n/**\n * Retrieve metadata items in parallel.\n *\n * @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}\n *\n * @example\n * ```\n * const data = await bulk([\n *   {\n *     metadataKey: 'instance',\n *   },\n *   {\n *     metadataKey: 'project/project-id',\n *   },\n * ] as const);\n *\n * // data.instance;\n * // data['project/project-id'];\n * ```\n *\n * @param properties The metadata properties to retrieve\n * @returns The metadata in `metadatakey:value` format\n */\nasync function bulk(properties) {\n    const r = {};\n    await Promise.all(properties.map(item => {\n        return (async () => {\n            const res = await metadataAccessor(item);\n            const key = item.metadataKey;\n            r[key] = res;\n        })();\n    }));\n    return r;\n}\nexports.bulk = bulk;\n/*\n * How many times should we retry detecting GCP environment.\n */\nfunction detectGCPAvailableRetries() {\n    return process.env.DETECT_GCP_RETRIES\n        ? Number(process.env.DETECT_GCP_RETRIES)\n        : 0;\n}\nlet cachedIsAvailableResponse;\n/**\n * Determine if the metadata server is currently available.\n */\nasync function isAvailable() {\n    if (process.env.METADATA_SERVER_DETECTION) {\n        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();\n        if (!(value in exports.METADATA_SERVER_DETECTION)) {\n            throw new RangeError(`Unknown \\`METADATA_SERVER_DETECTION\\` env variable. Got \\`${value}\\`, but it should be \\`${Object.keys(exports.METADATA_SERVER_DETECTION).join('`, `')}\\`, or unset`);\n        }\n        switch (value) {\n            case 'assume-present':\n                return true;\n            case 'none':\n                return false;\n            case 'bios-only':\n                return getGCPResidency();\n            case 'ping-only':\n            // continue, we want to ping the server\n        }\n    }\n    try {\n        // If a user is instantiating several GCP libraries at the same time,\n        // this may result in multiple calls to isAvailable(), to detect the\n        // runtime environment. We use the same promise for each of these calls\n        // to reduce the network load.\n        if (cachedIsAvailableResponse === undefined) {\n            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), \n            // If the default HOST_ADDRESS has been overridden, we should not\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\n            // a non-GCP environment):\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\n        }\n        await cachedIsAvailableResponse;\n        return true;\n    }\n    catch (e) {\n        const err = e;\n        if (process.env.DEBUG_AUTH) {\n            console.info(err);\n        }\n        if (err.type === 'request-timeout') {\n            // If running in a GCP environment, metadata endpoint should return\n            // within ms.\n            return false;\n        }\n        if (err.response && err.response.status === 404) {\n            return false;\n        }\n        else {\n            if (!(err.response && err.response.status === 404) &&\n                // A warning is emitted if we see an unexpected err.code, or err.code\n                // is not populated:\n                (!err.code ||\n                    ![\n                        'EHOSTDOWN',\n                        'EHOSTUNREACH',\n                        'ENETUNREACH',\n                        'ENOENT',\n                        'ENOTFOUND',\n                        'ECONNREFUSED',\n                    ].includes(err.code))) {\n                let code = 'UNKNOWN';\n                if (err.code)\n                    code = err.code;\n                process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, 'MetadataLookupWarning');\n            }\n            // Failure to resolve the metadata service means that it is not available.\n            return false;\n        }\n    }\n}\nexports.isAvailable = isAvailable;\n/**\n * reset the memoized isAvailable() lookup.\n */\nfunction resetIsAvailableCache() {\n    cachedIsAvailableResponse = undefined;\n}\nexports.resetIsAvailableCache = resetIsAvailableCache;\n/**\n * A cache for the detected GCP Residency.\n */\nexports.gcpResidencyCache = null;\n/**\n * Detects GCP Residency.\n * Caches results to reduce costs for subsequent calls.\n *\n * @see setGCPResidency for setting\n */\nfunction getGCPResidency() {\n    if (exports.gcpResidencyCache === null) {\n        setGCPResidency();\n    }\n    return exports.gcpResidencyCache;\n}\nexports.getGCPResidency = getGCPResidency;\n/**\n * Sets the detected GCP Residency.\n * Useful for forcing metadata server detection behavior.\n *\n * Set `null` to autodetect the environment (default behavior).\n * @see getGCPResidency for getting\n */\nfunction setGCPResidency(value = null) {\n    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();\n}\nexports.setGCPResidency = setGCPResidency;\n/**\n * Obtain the timeout for requests to the metadata server.\n *\n * In certain environments and conditions requests can take longer than\n * the default timeout to complete. This function will determine the\n * appropriate timeout based on the environment.\n *\n * @returns {number} a request timeout duration in milliseconds.\n */\nfunction requestTimeout() {\n    return getGCPResidency() ? 0 : 3000;\n}\nexports.requestTimeout = requestTimeout;\n__exportStar(__webpack_require__(/*! ./gcp-residency */ \"(action-browser)/./node_modules/gcp-metadata/build/src/gcp-residency.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nY3AtbWV0YWRhdGEvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLDZCQUE2QixHQUFHLG1CQUFtQixHQUFHLFlBQVksR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsaUNBQWlDLEdBQUcsZUFBZSxHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLDhCQUE4QixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQjtBQUNsWixpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBUTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBYTtBQUN4Qyx3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBaUI7QUFDakQsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQiw4QkFBOEI7QUFDOUIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixlQUFlLG1CQUFtQiw2Q0FBNkM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFB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O0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWEsbUJBQU8sQ0FBQyxnR0FBaUI7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9ydGN1dF9hcHAvLi9ub2RlX21vZHVsZXMvZ2NwLW1ldGFkYXRhL2J1aWxkL3NyYy9pbmRleC5qcz9hZGQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBTZWUgZmlsZSBMSUNFTlNFIGZvciBkZXRhaWwgb3IgY29weSBhdCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxdWVzdFRpbWVvdXQgPSBleHBvcnRzLnNldEdDUFJlc2lkZW5jeSA9IGV4cG9ydHMuZ2V0R0NQUmVzaWRlbmN5ID0gZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZSA9IGV4cG9ydHMucmVzZXRJc0F2YWlsYWJsZUNhY2hlID0gZXhwb3J0cy5pc0F2YWlsYWJsZSA9IGV4cG9ydHMuYnVsayA9IGV4cG9ydHMudW5pdmVyc2UgPSBleHBvcnRzLnByb2plY3QgPSBleHBvcnRzLmluc3RhbmNlID0gZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OID0gZXhwb3J0cy5IRUFERVJTID0gZXhwb3J0cy5IRUFERVJfVkFMVUUgPSBleHBvcnRzLkhFQURFUl9OQU1FID0gZXhwb3J0cy5TRUNPTkRBUllfSE9TVF9BRERSRVNTID0gZXhwb3J0cy5IT1NUX0FERFJFU1MgPSBleHBvcnRzLkJBU0VfUEFUSCA9IHZvaWQgMDtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IGpzb25CaWdpbnQgPSByZXF1aXJlKFwianNvbi1iaWdpbnRcIik7XG5jb25zdCBnY3BfcmVzaWRlbmN5XzEgPSByZXF1aXJlKFwiLi9nY3AtcmVzaWRlbmN5XCIpO1xuZXhwb3J0cy5CQVNFX1BBVEggPSAnL2NvbXB1dGVNZXRhZGF0YS92MSc7XG5leHBvcnRzLkhPU1RfQUREUkVTUyA9ICdodHRwOi8vMTY5LjI1NC4xNjkuMjU0JztcbmV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUyA9ICdodHRwOi8vbWV0YWRhdGEuZ29vZ2xlLmludGVybmFsLic7XG5leHBvcnRzLkhFQURFUl9OQU1FID0gJ01ldGFkYXRhLUZsYXZvcic7XG5leHBvcnRzLkhFQURFUl9WQUxVRSA9ICdHb29nbGUnO1xuZXhwb3J0cy5IRUFERVJTID0gT2JqZWN0LmZyZWV6ZSh7IFtleHBvcnRzLkhFQURFUl9OQU1FXTogZXhwb3J0cy5IRUFERVJfVkFMVUUgfSk7XG4vKipcbiAqIE1ldGFkYXRhIHNlcnZlciBkZXRlY3Rpb24gb3ZlcnJpZGUgb3B0aW9ucy5cbiAqXG4gKiBBdmFpbGFibGUgdmlhIGBwcm9jZXNzLmVudi5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OYC5cbiAqL1xuZXhwb3J0cy5NRVRBREFUQV9TRVJWRVJfREVURUNUSU9OID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgJ2Fzc3VtZS1wcmVzZW50JzogXCJkb24ndCB0cnkgdG8gcGluZyB0aGUgbWV0YWRhdGEgc2VydmVyLCBidXQgYXNzdW1lIGl0J3MgcHJlc2VudFwiLFxuICAgIG5vbmU6IFwiZG9uJ3QgdHJ5IHRvIHBpbmcgdGhlIG1ldGFkYXRhIHNlcnZlciwgYnV0IGRvbid0IHRyeSB0byB1c2UgaXQgZWl0aGVyXCIsXG4gICAgJ2Jpb3Mtb25seSc6IFwidHJlYXQgdGhlIHJlc3VsdCBvZiBhIEJJT1MgcHJvYmUgYXMgY2Fub25pY2FsIChkb24ndCBmYWxsIGJhY2sgdG8gcGluZ2luZylcIixcbiAgICAncGluZy1vbmx5JzogJ3NraXAgdGhlIEJJT1MgcHJvYmUsIGFuZCBnbyBzdHJhaWdodCB0byBwaW5naW5nJyxcbn0pO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIFVSTCB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBHQ0VfTUVUQURBVEFfSE9TVFxuICogZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEByZXR1cm5zIFRoZSBiYXNlIFVSTCwgZS5nLiwgaHR0cDovLzE2OS4yNTQuMTY5LjI1NC9jb21wdXRlTWV0YWRhdGEvdjEuXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICAgIGlmICghYmFzZVVybCkge1xuICAgICAgICBiYXNlVXJsID1cbiAgICAgICAgICAgIHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9JUCB8fFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9IT1NUIHx8XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5IT1NUX0FERFJFU1M7XG4gICAgfVxuICAgIC8vIElmIG5vIHNjaGVtZSBpcyBwcm92aWRlZCBkZWZhdWx0IHRvIEhUVFA6XG4gICAgaWYgKCEvXmh0dHBzPzpcXC9cXC8vLnRlc3QoYmFzZVVybCkpIHtcbiAgICAgICAgYmFzZVVybCA9IGBodHRwOi8vJHtiYXNlVXJsfWA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVVJMKGV4cG9ydHMuQkFTRV9QQVRILCBiYXNlVXJsKS5ocmVmO1xufVxuLy8gQWNjZXB0cyBhbiBvcHRpb25zIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgdXNlciB0byB0aGUgQVBJLiBJbiBwcmV2aW91c1xuLy8gdmVyc2lvbnMgb2YgdGhlIEFQSSwgaXQgcmVmZXJyZWQgdG8gYSBgUmVxdWVzdGAgb3IgYW4gYEF4aW9zYCByZXF1ZXN0XG4vLyBvcHRpb25zIG9iamVjdC4gIE5vdyBpdCByZWZlcnMgdG8gYW4gb2JqZWN0IHdpdGggdmVyeSBsaW1pdGVkIHByb3BlcnR5XG4vLyBuYW1lcy4gVGhpcyBpcyBoZXJlIHRvIGhlbHAgZW5zdXJlIHVzZXJzIGRvbid0IHBhc3MgaW52YWxpZCBvcHRpb25zIHdoZW5cbi8vIHRoZXkgIHVwZ3JhZGUgZnJvbSAwLjQgdG8gMC41IHRvIDAuOC5cbmZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdwYXJhbXMnOlxuICAgICAgICAgICAgY2FzZSAncHJvcGVydHknOlxuICAgICAgICAgICAgY2FzZSAnaGVhZGVycyc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxcyc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3FzJyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbi4gUGxlYXNlIHVzZSAncGFyYW1zJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtrZXl9JyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbWV0YWRhdGFBY2Nlc3Nvcih0eXBlLCBvcHRpb25zID0ge30sIG5vUmVzcG9uc2VSZXRyaWVzID0gMywgZmFzdEZhaWwgPSBmYWxzZSkge1xuICAgIGxldCBtZXRhZGF0YUtleSA9ICcnO1xuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFBY2Nlc3NvciA9IHR5cGU7XG4gICAgICAgIG1ldGFkYXRhS2V5ID0gbWV0YWRhdGFBY2Nlc3Nvci5tZXRhZGF0YUtleTtcbiAgICAgICAgcGFyYW1zID0gbWV0YWRhdGFBY2Nlc3Nvci5wYXJhbXMgfHwgcGFyYW1zO1xuICAgICAgICBoZWFkZXJzID0gbWV0YWRhdGFBY2Nlc3Nvci5oZWFkZXJzIHx8IGhlYWRlcnM7XG4gICAgICAgIG5vUmVzcG9uc2VSZXRyaWVzID0gbWV0YWRhdGFBY2Nlc3Nvci5ub1Jlc3BvbnNlUmV0cmllcyB8fCBub1Jlc3BvbnNlUmV0cmllcztcbiAgICAgICAgZmFzdEZhaWwgPSBtZXRhZGF0YUFjY2Vzc29yLmZhc3RGYWlsIHx8IGZhc3RGYWlsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0YWRhdGFLZXkgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1ldGFkYXRhS2V5ICs9IGAvJHtvcHRpb25zfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJvcGVydHkpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhS2V5ICs9IGAvJHtvcHRpb25zLnByb3BlcnR5fWA7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCBoZWFkZXJzO1xuICAgICAgICBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCBwYXJhbXM7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RNZXRob2QgPSBmYXN0RmFpbCA/IGZhc3RGYWlsTWV0YWRhdGFSZXF1ZXN0IDogZ2F4aW9zXzEucmVxdWVzdDtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdE1ldGhvZCh7XG4gICAgICAgICAgICB1cmw6IGAke2dldEJhc2VVcmwoKX0vJHttZXRhZGF0YUtleX1gLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi5leHBvcnRzLkhFQURFUlMsIC4uLmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHJldHJ5Q29uZmlnOiB7IG5vUmVzcG9uc2VSZXRyaWVzIH0sXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHJlcXVlc3RUaW1lb3V0KCksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFOiBub2RlLmpzIGNvbnZlcnRzIGFsbCBpbmNvbWluZyBoZWFkZXJzIHRvIGxvd2VyIGNhc2UuXG4gICAgICAgIGlmIChyZXMuaGVhZGVyc1tleHBvcnRzLkhFQURFUl9OQU1FLnRvTG93ZXJDYXNlKCldICE9PSBleHBvcnRzLkhFQURFUl9WQUxVRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGZyb20gbWV0YWRhdGEgc2VydmljZTogaW5jb3JyZWN0ICR7ZXhwb3J0cy5IRUFERVJfTkFNRX0gaGVhZGVyLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFyZXMuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZyb20gdGhlIG1ldGFkYXRhIHNlcnZpY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlcy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbkJpZ2ludC5wYXJzZShyZXMuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvKiBpZ25vcmUgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IGU7XG4gICAgICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBVbnN1Y2Nlc3NmdWwgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZhc3RGYWlsTWV0YWRhdGFSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZWNvbmRhcnlPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB1cmw6IG9wdGlvbnMudXJsLnJlcGxhY2UoZ2V0QmFzZVVybCgpLCBnZXRCYXNlVXJsKGV4cG9ydHMuU0VDT05EQVJZX0hPU1RfQUREUkVTUykpLFxuICAgIH07XG4gICAgLy8gV2UgcmFjZSBhIGNvbm5lY3Rpb24gYmV0d2VlbiBETlMvSVAgdG8gbWV0YWRhdGEgc2VydmVyLiBUaGVyZSBhcmUgYSBjb3VwbGVcbiAgICAvLyByZWFzb25zIGZvciB0aGlzOlxuICAgIC8vXG4gICAgLy8gMS4gdGhlIEROUyBpcyBzbG93IGluIHNvbWUgR0NQIGVudmlyb25tZW50czsgYnkgY2hlY2tpbmcgYm90aCwgd2UgbWlnaHRcbiAgICAvLyAgICBkZXRlY3QgdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgc2lnbmZpY2FudGx5IGZhc3Rlci5cbiAgICAvLyAyLiB3ZSBjYW4ndCBqdXN0IGNoZWNrIHRoZSBJUCwgd2hpY2ggaXMgdGFycGl0dGVkIGFuZCBzbG93IHRvIHJlc3BvbmRcbiAgICAvLyAgICBvbiBhIHVzZXIncyBsb2NhbCBtYWNoaW5lLlxuICAgIC8vXG4gICAgLy8gQWRkaXRpb25hbCBsb2dpYyBoYXMgYmVlbiBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjcmVhdGUgYW5cbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9uIGluIHNjZW5hcmlvcyB3aGVyZSBhIGZhaWx1cmUgaGFwcGVucyBzb21ldGltZVxuICAgIC8vIGFmdGVyIGEgc3VjY2Vzcy5cbiAgICAvL1xuICAgIC8vIE5vdGUsIGhvd2V2ZXIsIGlmIGEgZmFpbHVyZSBoYXBwZW5zIHByaW9yIHRvIGEgc3VjY2VzcywgYSByZWplY3Rpb24gc2hvdWxkXG4gICAgLy8gb2NjdXIsIHRoaXMgaXMgZm9yIGZvbGtzIHJ1bm5pbmcgbG9jYWxseS5cbiAgICAvL1xuICAgIGxldCByZXNwb25kZWQgPSBmYWxzZTtcbiAgICBjb25zdCByMSA9ICgwLCBnYXhpb3NfMS5yZXF1ZXN0KShvcHRpb25zKVxuICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAocmVzcG9uZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcjI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcjIgPSAoMCwgZ2F4aW9zXzEucmVxdWVzdCkoc2Vjb25kYXJ5T3B0aW9ucylcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHIxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3IxLCByMl0pO1xufVxuLyoqXG4gKiBPYnRhaW4gbWV0YWRhdGEgZm9yIHRoZSBjdXJyZW50IEdDRSBpbnN0YW5jZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL21ldGFkYXRhL3ByZWRlZmluZWQtbWV0YWRhdGEta2V5c31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBzZXJ2aWNlQWNjb3VudDoge30gPSBhd2FpdCBpbnN0YW5jZSgnc2VydmljZS1hY2NvdW50cy8nKTtcbiAqIGNvbnN0IHNlcnZpY2VBY2NvdW50RW1haWw6IHN0cmluZyA9IGF3YWl0IGluc3RhbmNlKCdzZXJ2aWNlLWFjY291bnRzL2RlZmF1bHQvZW1haWwnKTtcbiAqIGBgYFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gaW5zdGFuY2Uob3B0aW9ucykge1xuICAgIHJldHVybiBtZXRhZGF0YUFjY2Vzc29yKCdpbnN0YW5jZScsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuLyoqXG4gKiBPYnRhaW4gbWV0YWRhdGEgZm9yIHRoZSBjdXJyZW50IEdDUCBwcm9qZWN0LlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jb21wdXRlL2RvY3MvbWV0YWRhdGEvcHJlZGVmaW5lZC1tZXRhZGF0YS1rZXlzfVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IHByb2plY3RJZDogc3RyaW5nID0gYXdhaXQgcHJvamVjdCgncHJvamVjdC1pZCcpO1xuICogY29uc3QgbnVtZXJpY1Byb2plY3RJZDogbnVtYmVyID0gYXdhaXQgcHJvamVjdCgnbnVtZXJpYy1wcm9qZWN0LWlkJyk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHByb2plY3Qob3B0aW9ucykge1xuICAgIHJldHVybiBtZXRhZGF0YUFjY2Vzc29yKCdwcm9qZWN0Jywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnByb2plY3QgPSBwcm9qZWN0O1xuLyoqXG4gKiBPYnRhaW4gbWV0YWRhdGEgZm9yIHRoZSBjdXJyZW50IHVuaXZlcnNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9jb21wdXRlL2RvY3MvbWV0YWRhdGEvcHJlZGVmaW5lZC1tZXRhZGF0YS1rZXlzfVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IHVuaXZlcnNlRG9tYWluOiBzdHJpbmcgPSBhd2FpdCB1bml2ZXJzZSgndW5pdmVyc2VfZG9tYWluJyk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdW5pdmVyc2Uob3B0aW9ucykge1xuICAgIHJldHVybiBtZXRhZGF0YUFjY2Vzc29yKCd1bml2ZXJzZScsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy51bml2ZXJzZSA9IHVuaXZlcnNlO1xuLyoqXG4gKiBSZXRyaWV2ZSBtZXRhZGF0YSBpdGVtcyBpbiBwYXJhbGxlbC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL21ldGFkYXRhL3ByZWRlZmluZWQtbWV0YWRhdGEta2V5c31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBkYXRhID0gYXdhaXQgYnVsayhbXG4gKiAgIHtcbiAqICAgICBtZXRhZGF0YUtleTogJ2luc3RhbmNlJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG1ldGFkYXRhS2V5OiAncHJvamVjdC9wcm9qZWN0LWlkJyxcbiAqICAgfSxcbiAqIF0gYXMgY29uc3QpO1xuICpcbiAqIC8vIGRhdGEuaW5zdGFuY2U7XG4gKiAvLyBkYXRhWydwcm9qZWN0L3Byb2plY3QtaWQnXTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIFRoZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIHRvIHJldHJpZXZlXG4gKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgaW4gYG1ldGFkYXRha2V5OnZhbHVlYCBmb3JtYXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYnVsayhwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgciA9IHt9O1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb3BlcnRpZXMubWFwKGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1ldGFkYXRhQWNjZXNzb3IoaXRlbSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBpdGVtLm1ldGFkYXRhS2V5O1xuICAgICAgICAgICAgcltrZXldID0gcmVzO1xuICAgICAgICB9KSgpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydHMuYnVsayA9IGJ1bGs7XG4vKlxuICogSG93IG1hbnkgdGltZXMgc2hvdWxkIHdlIHJldHJ5IGRldGVjdGluZyBHQ1AgZW52aXJvbm1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEdDUEF2YWlsYWJsZVJldHJpZXMoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkRFVEVDVF9HQ1BfUkVUUklFU1xuICAgICAgICA/IE51bWJlcihwcm9jZXNzLmVudi5ERVRFQ1RfR0NQX1JFVFJJRVMpXG4gICAgICAgIDogMDtcbn1cbmxldCBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIG1ldGFkYXRhIHNlcnZlciBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICovXG5hc3luYyBmdW5jdGlvbiBpc0F2YWlsYWJsZSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2Nlc3MuZW52Lk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04udHJpbSgpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghKHZhbHVlIGluIGV4cG9ydHMuTUVUQURBVEFfU0VSVkVSX0RFVEVDVElPTikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbmtub3duIFxcYE1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT05cXGAgZW52IHZhcmlhYmxlLiBHb3QgXFxgJHt2YWx1ZX1cXGAsIGJ1dCBpdCBzaG91bGQgYmUgXFxgJHtPYmplY3Qua2V5cyhleHBvcnRzLk1FVEFEQVRBX1NFUlZFUl9ERVRFQ1RJT04pLmpvaW4oJ2AsIGAnKX1cXGAsIG9yIHVuc2V0YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYXNzdW1lLXByZXNlbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAnYmlvcy1vbmx5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0R0NQUmVzaWRlbmN5KCk7XG4gICAgICAgICAgICBjYXNlICdwaW5nLW9ubHknOlxuICAgICAgICAgICAgLy8gY29udGludWUsIHdlIHdhbnQgdG8gcGluZyB0aGUgc2VydmVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgYSB1c2VyIGlzIGluc3RhbnRpYXRpbmcgc2V2ZXJhbCBHQ1AgbGlicmFyaWVzIGF0IHRoZSBzYW1lIHRpbWUsXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBtdWx0aXBsZSBjYWxscyB0byBpc0F2YWlsYWJsZSgpLCB0byBkZXRlY3QgdGhlXG4gICAgICAgIC8vIHJ1bnRpbWUgZW52aXJvbm1lbnQuIFdlIHVzZSB0aGUgc2FtZSBwcm9taXNlIGZvciBlYWNoIG9mIHRoZXNlIGNhbGxzXG4gICAgICAgIC8vIHRvIHJlZHVjZSB0aGUgbmV0d29yayBsb2FkLlxuICAgICAgICBpZiAoY2FjaGVkSXNBdmFpbGFibGVSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWNoZWRJc0F2YWlsYWJsZVJlc3BvbnNlID0gbWV0YWRhdGFBY2Nlc3NvcignaW5zdGFuY2UnLCB1bmRlZmluZWQsIGRldGVjdEdDUEF2YWlsYWJsZVJldHJpZXMoKSwgXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVmYXVsdCBIT1NUX0FERFJFU1MgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgd2Ugc2hvdWxkIG5vdFxuICAgICAgICAgICAgLy8gbWFrZSBhbiBlZmZvcnQgdG8gdHJ5IFNFQ09OREFSWV9IT1NUX0FERFJFU1MgKGFzIHdlIGFyZSBsaWtlbHkgaW5cbiAgICAgICAgICAgIC8vIGEgbm9uLUdDUCBlbnZpcm9ubWVudCk6XG4gICAgICAgICAgICAhKHByb2Nlc3MuZW52LkdDRV9NRVRBREFUQV9JUCB8fCBwcm9jZXNzLmVudi5HQ0VfTUVUQURBVEFfSE9TVCkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUdfQVVUSCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyci50eXBlID09PSAncmVxdWVzdC10aW1lb3V0Jykge1xuICAgICAgICAgICAgLy8gSWYgcnVubmluZyBpbiBhIEdDUCBlbnZpcm9ubWVudCwgbWV0YWRhdGEgZW5kcG9pbnQgc2hvdWxkIHJldHVyblxuICAgICAgICAgICAgLy8gd2l0aGluIG1zLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShlcnIucmVzcG9uc2UgJiYgZXJyLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSAmJlxuICAgICAgICAgICAgICAgIC8vIEEgd2FybmluZyBpcyBlbWl0dGVkIGlmIHdlIHNlZSBhbiB1bmV4cGVjdGVkIGVyci5jb2RlLCBvciBlcnIuY29kZVxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBwb3B1bGF0ZWQ6XG4gICAgICAgICAgICAgICAgKCFlcnIuY29kZSB8fFxuICAgICAgICAgICAgICAgICAgICAhW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0VIT1NURE9XTicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUhPU1RVTlJFQUNIJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTkVUVU5SRUFDSCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5PRU5UJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTk9URk9VTkQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VDT05OUkVGVVNFRCcsXG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMoZXJyLmNvZGUpKSkge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gJ1VOS05PV04nO1xuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGVyci5jb2RlO1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYHJlY2VpdmVkIHVuZXhwZWN0ZWQgZXJyb3IgPSAke2Vyci5tZXNzYWdlfSBjb2RlID0gJHtjb2RlfWAsICdNZXRhZGF0YUxvb2t1cFdhcm5pbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhaWx1cmUgdG8gcmVzb2x2ZSB0aGUgbWV0YWRhdGEgc2VydmljZSBtZWFucyB0aGF0IGl0IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmlzQXZhaWxhYmxlID0gaXNBdmFpbGFibGU7XG4vKipcbiAqIHJlc2V0IHRoZSBtZW1vaXplZCBpc0F2YWlsYWJsZSgpIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gcmVzZXRJc0F2YWlsYWJsZUNhY2hlKCkge1xuICAgIGNhY2hlZElzQXZhaWxhYmxlUmVzcG9uc2UgPSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLnJlc2V0SXNBdmFpbGFibGVDYWNoZSA9IHJlc2V0SXNBdmFpbGFibGVDYWNoZTtcbi8qKlxuICogQSBjYWNoZSBmb3IgdGhlIGRldGVjdGVkIEdDUCBSZXNpZGVuY3kuXG4gKi9cbmV4cG9ydHMuZ2NwUmVzaWRlbmN5Q2FjaGUgPSBudWxsO1xuLyoqXG4gKiBEZXRlY3RzIEdDUCBSZXNpZGVuY3kuXG4gKiBDYWNoZXMgcmVzdWx0cyB0byByZWR1Y2UgY29zdHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4gKlxuICogQHNlZSBzZXRHQ1BSZXNpZGVuY3kgZm9yIHNldHRpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0R0NQUmVzaWRlbmN5KCkge1xuICAgIGlmIChleHBvcnRzLmdjcFJlc2lkZW5jeUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgIHNldEdDUFJlc2lkZW5jeSgpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZTtcbn1cbmV4cG9ydHMuZ2V0R0NQUmVzaWRlbmN5ID0gZ2V0R0NQUmVzaWRlbmN5O1xuLyoqXG4gKiBTZXRzIHRoZSBkZXRlY3RlZCBHQ1AgUmVzaWRlbmN5LlxuICogVXNlZnVsIGZvciBmb3JjaW5nIG1ldGFkYXRhIHNlcnZlciBkZXRlY3Rpb24gYmVoYXZpb3IuXG4gKlxuICogU2V0IGBudWxsYCB0byBhdXRvZGV0ZWN0IHRoZSBlbnZpcm9ubWVudCAoZGVmYXVsdCBiZWhhdmlvcikuXG4gKiBAc2VlIGdldEdDUFJlc2lkZW5jeSBmb3IgZ2V0dGluZ1xuICovXG5mdW5jdGlvbiBzZXRHQ1BSZXNpZGVuY3kodmFsdWUgPSBudWxsKSB7XG4gICAgZXhwb3J0cy5nY3BSZXNpZGVuY3lDYWNoZSA9IHZhbHVlICE9PSBudWxsID8gdmFsdWUgOiAoMCwgZ2NwX3Jlc2lkZW5jeV8xLmRldGVjdEdDUFJlc2lkZW5jeSkoKTtcbn1cbmV4cG9ydHMuc2V0R0NQUmVzaWRlbmN5ID0gc2V0R0NQUmVzaWRlbmN5O1xuLyoqXG4gKiBPYnRhaW4gdGhlIHRpbWVvdXQgZm9yIHJlcXVlc3RzIHRvIHRoZSBtZXRhZGF0YSBzZXJ2ZXIuXG4gKlxuICogSW4gY2VydGFpbiBlbnZpcm9ubWVudHMgYW5kIGNvbmRpdGlvbnMgcmVxdWVzdHMgY2FuIHRha2UgbG9uZ2VyIHRoYW5cbiAqIHRoZSBkZWZhdWx0IHRpbWVvdXQgdG8gY29tcGxldGUuIFRoaXMgZnVuY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlXG4gKiBhcHByb3ByaWF0ZSB0aW1lb3V0IGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhIHJlcXVlc3QgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHJlcXVlc3RUaW1lb3V0KCkge1xuICAgIHJldHVybiBnZXRHQ1BSZXNpZGVuY3koKSA/IDAgOiAzMDAwO1xufVxuZXhwb3J0cy5yZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2djcC1yZXNpZGVuY3lcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/gcp-metadata/build/src/index.js\n");

/***/ })

};
;